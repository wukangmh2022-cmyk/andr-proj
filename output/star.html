<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>True PBR Solar System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #info {
            position: absolute;
            top: 20px; left: 20px; color: #aaa; font-family: sans-serif;
            pointer-events: none; text-shadow: 1px 1px 2px black;
        }
        .highlight { color: #fff; font-weight: bold; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info">
        PBR 渲染内核 | <span class="highlight">拖动鼠标旋转</span><br>
        观察重点：晨昏线交界处的山脉阴影、海洋的高光反射、月球投射在地球上的影子
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let earth, moon, sunLight;

        // --- 1. 纹理生成器 (核心：不使用外部图片，用代码生成PBR贴图) ---
        
        // 简单的伪随机噪声函数
        function pseudoNoise(x, y) {
            let n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
            return n - Math.floor(n);
        }

        // 生成地形高程数据
        function getHeight(x, y, width, height) {
            const nx = x / width * 10.0;
            const ny = y / height * 10.0;
            // 叠加几层噪声模拟大陆形状
            let val = pseudoNoise(Math.floor(nx), Math.floor(ny)); 
            val += pseudoNoise(Math.floor(nx*2), Math.floor(ny*2)) * 0.5;
            return val / 1.5;
        }

        function generatePBRTextures() {
            const size = 1024;
            const canvasColor = document.createElement('canvas');
            const canvasNormal = document.createElement('canvas');
            const canvasRough = document.createElement('canvas');
            
            canvasColor.width = canvasNormal.width = canvasRough.width = size;
            canvasColor.height = canvasNormal.height = canvasRough.height = size;
            
            const ctxC = canvasColor.getContext('2d');
            const ctxN = canvasNormal.getContext('2d');
            const ctxR = canvasRough.getContext('2d');

            const imgDataC = ctxC.createImageData(size, size);
            const imgDataN = ctxN.createImageData(size, size);
            const imgDataR = ctxR.createImageData(size, size);

            // 遍历像素生成贴图
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const i = (y * size + x) * 4;
                    
                    // 获取当前点和周围点的高度，用于计算法线
                    const h = getHeight(x, y, size, size);
                    const hR = getHeight(x+1, y, size, size);
                    const hU = getHeight(x, y-1, size, size);

                    // 设定阈值区分海洋和陆地
                    const isOcean = h < 0.45;

                    // 1. 颜色贴图 (Albedo)
                    if (isOcean) {
                        imgDataC.data[i] = 10;   // R
                        imgDataC.data[i+1] = 20; // G
                        imgDataC.data[i+2] = 60; // B (深蓝海)
                    } else {
                        const shade = 50 + (h * 100);
                        imgDataC.data[i] = shade;     // R
                        imgDataC.data[i+1] = shade - 20; // G (土黄/绿)
                        imgDataC.data[i+2] = shade - 40; // B
                    }
                    imgDataC.data[i+3] = 255;

                    // 2. 粗糙度贴图 (Roughness)
                    // 海洋光滑(黑=0)，陆地粗糙(白=1)
                    const rough = isOcean ? 30 : 200; 
                    imgDataR.data[i] = imgDataR.data[i+1] = imgDataR.data[i+2] = rough;
                    imgDataR.data[i+3] = 255;

                    // 3. 法线贴图 (Normal Map) - 赋予体积感的关键
                    // 计算斜率
                    const dx = (h - hR) * 15.0; // 强度系数
                    const dy = (h - hU) * 15.0;
                    const dz = 1.0;
                    
                    // 归一化并映射到 0-255
                    let len = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    let nx = (dx/len) * 0.5 + 0.5;
                    let ny = (dy/len) * 0.5 + 0.5;
                    let nz = (dz/len) * 0.5 + 0.5;

                    imgDataN.data[i] = nx * 255;
                    imgDataN.data[i+1] = ny * 255;
                    imgDataN.data[i+2] = nz * 255;
                    imgDataN.data[i+3] = 255;
                }
            }

            ctxC.putImageData(imgDataC, 0, 0);
            ctxN.putImageData(imgDataN, 0, 0);
            ctxR.putImageData(imgDataR, 0, 0);

            return {
                map: new THREE.CanvasTexture(canvasColor),
                normalMap: new THREE.CanvasTexture(canvasNormal),
                roughnessMap: new THREE.CanvasTexture(canvasRough)
            };
        }

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            
            // 2. 渲染器配置 (开启阴影和物理光照模式)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // 开启阴影映射
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 柔和阴影
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // 电影感色调
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 5, 20); // 斜侧视角观察晨昏线

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // 3. 灯光系统 (关键：单主光源，制造强对比)
            const ambient = new THREE.AmbientLight(0x404040, 0.02); // 极弱环境光，太空接近全黑
            scene.add(ambient);

            sunLight = new THREE.PointLight(0xffffff, 2.5);
            sunLight.position.set(50, 10, 50); // 太阳位置
            sunLight.castShadow = true;
            
            // 优化阴影质量
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);

            // 太阳本体（只是为了看着像个光源）
            const sunMesh = new THREE.Mesh(
                new THREE.SphereGeometry(2, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0xffffff }) // 发光材质
            );
            sunMesh.position.copy(sunLight.position);
            scene.add(sunMesh);

            // 4. 地球 (PBR 材质应用)
            const textures = generatePBRTextures();
            
            const earthGeo = new THREE.SphereGeometry(5, 64, 64); // 高分段数配合法线贴图
            const earthMat = new THREE.MeshStandardMaterial({
                map: textures.map,
                normalMap: textures.normalMap,
                normalScale: new THREE.Vector2(2, 2), // 增强凹凸感
                roughnessMap: textures.roughnessMap,
                metalness: 0.1,
                roughness: 1.0
            });
            earth = new THREE.Mesh(earthGeo, earthMat);
            earth.castShadow = true;
            earth.receiveShadow = true; // 接收来自月球的阴影
            scene.add(earth);

            // 5. 大气层 (体积光伪装)
            const atmoGeo = new THREE.SphereGeometry(5.1, 64, 64);
            const atmoMat = new THREE.MeshPhongMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.15,
                side: THREE.FrontSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const atmosphere = new THREE.Mesh(atmoGeo, atmoMat);
            earth.add(atmosphere);

            // 6. 月球 (制造阴影投射)
            const moonGeo = new THREE.SphereGeometry(1.2, 32, 32);
            
            // 月球也是凹凸不平的
            const moonTex = generatePBRTextures(); // 复用生成逻辑，虽然颜色不太对，但有凹凸感
            const moonMat = new THREE.MeshStandardMaterial({
                color: 0x888888,
                normalMap: moonTex.normalMap,
                roughness: 0.9
            });
            
            moon = new THREE.Mesh(moonGeo, moonMat);
            moon.castShadow = true; // 关键：月球投射阴影
            moon.receiveShadow = true;
            scene.add(moon);
            
            // 7. 星空背景 (极暗，衬托主体)
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            for(let i=0; i<2000; i++) {
                const x = (Math.random()-0.5) * 600;
                const y = (Math.random()-0.5) * 600;
                const z = (Math.random()-0.5) * 600;
                starPos.push(x,y,z);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0x555555, size: 0.5}));
            scene.add(stars);
            
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.0005;

            // 地球自转
            earth.rotation.y += 0.002;

            // 月球公转
            // 让月球在地球和太阳之间穿过，制造日食阴影
            const radius = 12;
            moon.position.x = Math.cos(time) * radius;
            moon.position.z = Math.sin(time) * radius;
            moon.position.y = Math.sin(time * 0.5) * 2; // 稍微有点倾角
            
            // 月球自转（潮汐锁定效果忽略，只为了看清楚纹理）
            moon.rotation.y += 0.01;

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>